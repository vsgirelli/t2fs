LabBook com anota√ß√µes relativas ao desenvolvimento do trabalho 2 da disciplina
de Sistemas Operacionais I, UFRGS -> T2FS (libt2fs.a)

# 12/10/18

-   Leitura da especifica√ß√£o do trabalho:
* FS com hierarquia em √°rvore
* Aloca√ß√£o encadeada para gerenciamento de espa√ßo em disco
* Esquema parecido com a FAT:
  Em resumo, a FAT √© uma tabela, File Allocation Table.
  Na FAT tem os endere√ßos para o bloco subsequente:
  - L√™ o bloco 217 dos dados.
  - L√™ o bloco 217 da FAT: ele cont√©m o ponteiro para o pr√≥ximo bloco, o 619.
  - L√™ o bloco 619 dos dados.
  - L√™ o bloco 619 da FAT: ele aponta para o pr√≥ximo bloco de dados do arquivo.
And so on.

* SETORES: tamanho l√≥gico de 256 bytes.
* Setor 0: superbloco (infos sobre o disco). Ocupa 1 setor l√≥gico.
* Setores 1-k: FAT. K setores l√≥gicos.
* Restante dos blocos C s√£o de clusters (dados). Os clusters 0 e 1 s√£o
  reservados. Clusters s√£o formados por n setores l√≥gicos, e seu identificador
  possui 32 bits. O n√∫mero de setores cont√≠guos que formam um cluster √© indicado
  na tabela do superbloco, no campo SectorsPerCluster.

* Hierarquia em √°rvore com links simb√≥licos.
* Pathname (como no Linux).
* Caminhos absolutos (/) e relativos (./).

* Arquivos:
  - Regulares de tamanho vari√°vel. ASCII ou bin√°rios.
  - Diret√≥rio, limitado ao tamanho de um cluster. Composto por registros.
* Registros:
  - Arquivo regular
  - Arquivo de diret√≥rio
  - Links simb√≥licos

* Infos sobre livre, ocupado ou badcluster fornecidos na FAT.
* Clusters ocupados: ou EOF se o cluster for o √∫ltimo do arquivo, ou o n√∫mero do
  pr√≥ximo cluster onde o arquivo continua (encadeamento).

* FAT:
Seu tamanho exato em setores l√≥gicos depende da quantidade de setores l√≥gicos
que comp√µem um cluster e do tamanho total da parti√ß√£o T2FS. √â organizada como
uma LISTA COM C ELEMENTOS DE 32 BITS (4 bytes). Cada elemento dessa lista
corresponde a um cluster de dados, ent√£o o tamanho de entradas da FAT √© o mesmo
da quantidade de clusters de dados.

(4 Bytes)
0x00000000    O cluster est√° livre

0x00000001    N√£o deve aparecer em nenhum dos campos de um elemento da FAT.

0x00000002 a  N√∫mero do pr√≥ximo cluster do arquivo.
0xFFFFFFFD

0xFFFFFFFE    Cluster com defeito. N√£o pode ser alocado para dados.

0xFFFFFFFF    √öltimo cluster do arquivo (EOF).

Ent√£o, ex de registro:
Dir: File1.txt - 217 (217 √© o primeiro cluster do arquivo)
  - L√™ o bloco 217 dos dados.
  - L√™ o bloco 217 da FAT: ele cont√©m o ponteiro para o pr√≥ximo bloco, o 619.
  - L√™ o bloco 619 dos dados.
  - L√™ o bloco 619 da FAT: ele aponta para o pr√≥ximo bloco de dados do arquivo.

* Diret√≥rios:
Ocupam um √∫nico cluster (a quantidade de entradas √© ent√£o limitada, causando
erro caso se deseje inserir uma nova entrada e o Diret√≥rio estiver cheio).
√â um arquivo com N entradas. Duas s√£o reservadas para o diret√≥rio pai .. e o
diret√≥rio corrente . .

Estrutura de um registro:
Total de 64 bytes por registro (considerando o tamanho do cluster, a quantidade
de registros de um dir √© limitada).
(Posi√ß√£o relativa)  Tamanho               Descri√ß√£o
                    (bytes)
      0               1         Tipo da entrada. Se o registro for v√°lido,
                                indica o tipo do arquivo:
                                0x00 - inv√°lido
                                0x01 - regular
                                0x02 - diret√≥rio
                                0x03 - link simb√≥lico

      1               51        String com o nome do arquivo, em ASCII. Case
                                sensitive. (Preencher com \0 (0x00)).

      52              4         Tamanho do arquivo, em n√∫mero de bytes. Se o
                                registro for de um dir ou de um link, ent√£o esse
                                valor corresponde ao tamanho do bloco. N√£o √© um
                                m√∫ltiplo do tamanho dos clusters.

      56              4         Tamanho do arquivo, em n√∫mero de clusters. Se o
                                registro for de um dir ou de um link, fixo em 1.

      60              4         N√∫mero do primeiro cluster de dados dessa
                                entrada do diret√≥rio.

* Diret√≥rio raiz:
Mesma estrutura de um dir qualquer. S√≥ deve-se observar que a entrada .. aponta
para ele mesmo e ele √© atribu√≠do a um cluster fixo, indicado no superbloco.

* Componentes do T2FS:
- Fornecidos: disco T2FS e apidisk.
- A ser entregue: implementa√ß√£o do sistema de arquivos.

* A biblioteca a ser desenvolvida corresponde a uma interface para que
  programas de usu√°rio e utilit√°rios possam se comunicar com o dispositivo.
A camada de apidisk √© fornecida e emula o comportamento do driver do
dispositivo. O disco √© um arquivo que simula um disco formatado em T2FS. As
chamadas da apidisk s√£o fun√ß√µes de leitura e escrita de SETORES L√ìGICOS.

* Infos contidas no superbloco:
- Identifica√ß√£o do FS.
- Vers√£o.
- Quantidade de setores l√≥gicos do superbloco (fun√ß√µeixo em 1).
- Tamanho total (bytes) da parti√ß√£o T2FS (superbloco, FAT e clusters de dados).
- Quantidade total de setores l√≥gicos da parti√ß√£o.
- N√∫mero de setores l√≥gicos por cluster.
- N√∫mero do setor l√≥gico em que a FAT inicia (fixo em 1).
- Cluster de in√≠cio do diret√≥rio raiz.
- Primeiro setor l√≥gico da √°rea de blocos de dados (clusters de dados.)

* Para todos os arquivos existentes no T2FS existe um registro na entrada do
diret√≥rio. Entradas assim possuem o mesmo formato em qualquer n√≠vel da
hierarquia de diret√≥rios. Portanto, s√£o tipos de arquivos: diret√≥rio cont√©m
informa√ß√µes sobre outros arquivos, diret√≥rios ou links. Arquivos normais cont√™m
dados. Arquivos do tipo link simb√≥lico s√£o arquivos com apenas um bloco, e seu
conte√∫do √© uma string que corresponde ao caminho absoluto ou relativo para o objeto.

Sempre que um arquivo for criado, deve ser adicionada uma entrada de Diret√≥rio
no dir informado pelo caminho (que pode ser relativo ou absoluto), e um primeiro
cluster deve ser alocado. √Ä medida que esse arquivo cresce, devem ser
alocados e encadeados novos clusters. O mesmo controle deve ser feito com o
"descrescimento" do arquivo. Ao remover um arquivo, todos os clusters que o
comp√µem devem ser liberados.

Ao criar-se um dir, deve-se alocar duas entradas de dir para os dir . e  .. .
Para remover um dir √© necess√°rio que ele esteja vazio (√† exe√ß√£o dos . e ..).

Links simb√≥licos tbm ocupam uma entrada no dir, e tbm ocupam apenas um cluster.
Ao remover o link, apenas remove-se a entrada do dir e o cluster dele. Se o
arquivo regular apontado pelo link for removido, o link fica inconsistente. It
seems nothing needs to be done about it, fuck the user.

* Our job:
Criar a libt2fs que permite acesso aos arquivos do T2FS.
Algumas EDs necess√°rias e os prot√≥tipos das fun√ß√µes est√£o definidas no arquivo
t2fs.h.
O T2FS deve permitir que seja poss√≠vel ter-se at√© 10 arquivos regulares abertos
simultaneamente, podendo-se abrir o mesmo arquivo mais de uma vez.
TODO verificar os prot√≥tipos todos.

* apidisk:
Realiza opera√ß√µes de I/O no subsistema de I/O do disco. Opera√ß√µes sobre setores
l√≥gicos do disco, numerados sequencialmente a partir do zero e de tamanho fixo
256 bytes. Fun√ß√µes de read_sector, write_sector.



# 13/10/18


- Sobre links simb√≥licos:
Ao criar um link, deve-se alocar uma entrada no diret√≥rio e UM cluster. Neste
cluster, que deve ser √∫nico para links, deve-se colocar o endere√ßo para o qual
esse link aponta, e n√£o o endere√ßo do cluster de in√≠cio do arquivo. Se for posto
o primeiro endere√ßo de cluster, mesmo que o arquivo deixe de existir o link pode
continuar apontando para aquele endere√ßo e acessando os dados salvos. Portanto,
deve-se colocar o path do arquivo. Desse modo, caso tente-se acessar o arquivo
depois de ele ser removido, n√£o existir√° uma entrada no diret√≥rio para aquele
arquivo, ent√£o n√£o h√° problemas de acessar dados indevidos.

- Sobre o que √© salvo na entrada da FAT:
Em cada entrada da FAT o que existe √© o endere√ßo para o pr√≥ximo cluster do
arquivo, ou seja, quando eu chegar no bloco 300 e  ele for o √∫ltimo cluster do
arquivo, a sua entrada na FAT vai conter o valor 0xFFFFFFFF.
Al√©m disso, a FAT √© um vetor unsigned int: cada posi√ß√£o do vetor vai corresponder
a um cluster de dados. O tamanho desse vetor √© dado pela info de tamanho da FAT
contida no superbloco.

- Os blocos de dados n√£o v√£o ficar em mem√≥ria!!!!!!!

- Quando se quer fazer a leitura de um cluster, deve-se usar a apidisk. Observar
  que o endere√ßo do cluster n√£o indica necessariamente o endere√ßo do setor l√≥gico
no disco, pois um cluster pode ser formado por n setores l√≥gicos.

- Leituras de arquivo diret√≥rio dever√£o fazer um casting pra ED de diret√≥rio:
Cada dir √© um vetor de x t2fs_record (x = cluster_size / 64):
t2fs_record dir_vec[cluster_size/64];
Assim, cada um dos elementos do vetor dir_vec vai ser um registro do diret√≥rio
que est√° sendo lido. Assim, quando o diret√≥rio for criado, todos os registros
devem ser inicializados com TypeVal = 0 (arquivo inv√°lido).

- Como pode-se ter at√© 10 arquivos regulres abertos, ent√£o provavelmente √©
necess√°rio fazer aloca√ß√£o din√¢mica de arquivos Regulares.

- ED para arquivos abertos:
t2fs_record do arquivo
current postion pointer (em bytes)

*** GLOBAIS:
current dir (tbm com seu t2fs_record)
FAT
vetor de 10 arquivos abertos



# 14/10/18

- Abrir arquivos (regulares, Diret√≥rios ou links):
Para abrir qualquer tipo de arquivo deve-se verificar a exist√™ncia desse
arquivo. A exist√™ncia dele tanto corresponde a existir uma entrada em um
diret√≥rio para ele, quanto ser oferecido um path v√°lido. Portanto, antes de
abrir arquivos, sejam eles regulares, diret√≥rios ou links, deve-se verificar o
path informado. Por isso, vou criar as fun√ß√µes checkPath, que vai fazer a
verificac√£o do path informado, retornando um bool.



# 31/10/18

-   Rellou i missed you :)


# 05/11/18


-   Tentanu entender casting:
(type name) expr
double mean = (double) sum / count;
o operador de cast tem precedÍncia sobre a div, ent„o ele opera antes em sum e
depois È feita a divis„o.
Type hierarchy:
long double
  ^
double
  ^
float
  ^
unsigned long long
  ^
long long
  ^
unsigned long
  ^
long
  ^
unsigned int
  ^
int

Functions that perform data type conversion:
atof : string to float
atoi : string to  int
atol : string to long
itoa : int to string
ltoa : long to String

Accordingly to stack overflow, it is wrong to cast a malloc, becaus de void
pointer returned by malloc is automatically converted to the correct type.
malloc allocates based on the byte count, not on the type.


Also, for allocating and initializing with zeros, use calloc.
